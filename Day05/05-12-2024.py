from pathlib import Path
from itertools import combinations
import re

file_path = Path(__file__).with_name("input.txt")
with file_path.open("r") as f:
    file_content = f.read().split()

# -----General----
instructions_pattern = r"[0-9]+\|[0-9]+"
page_ordering_rules = []
page_numbers = []

for item in file_content:
    if re.match(instructions_pattern, item):
        cleaned_rule = tuple([int(i) for i in item.split("|")])
        page_ordering_rules.append(cleaned_rule)
    else:
        cleaned_number = [int(i) for i in item.split(",")]
        page_numbers.append(cleaned_number)

def find_instructions(page_ordering_rules, page_numbers, correct):
    correct_instructions = []
    total_middle = 0
    number_combinations = []

    for numbers in page_numbers:
        number_combinations.append(
            {
                "page_numbers": numbers,
                "combinations": list(combinations(numbers, 2)),
                "append": correct,
                "failed": []
            }
        )
    
    for pages in number_combinations:

        for rule in page_ordering_rules:

            if rule[::-1] in pages["combinations"]:
                pages["append"] = not correct
                pages["failed"].append(rule)
                continue

            if (pages["append"] != (not correct)) and (rule in pages["combinations"]):
                pages["append"] = correct

        if pages["append"]:
            correct_instructions.append(pages)
            total_middle += pages["page_numbers"][len(pages["page_numbers"]) // 2]
    
    return correct_instructions, total_middle

# -----Code Part 1-----

def part1():
    result = find_instructions(page_ordering_rules, page_numbers, True)[1]
    print(result)

part1()

# -----Code Part 2-----

def part2():
    instructions = find_instructions(page_ordering_rules, page_numbers, False)[0]
    print(instructions)
    
part2()

# Not solved for now

# -----Documentation-----
# This code for this challenge was written without the help of AI. The documentation was generated by ChatGPT.

"""
# Documentation for the Code

This script processes a file named `test.txt` to evaluate page numbering and ordering rules. The script parses a set of instructions and page numbers, validates them against the rules, and performs calculations based on the middle values of valid page sets. The code is designed with flexibility in mind, supporting two modes of operation (Part 1 and Part 2) to handle different validation criteria.

**Note:** Part 2 of the challenge is not fully solved in this script.

## Input File Format
- The input file `test.txt` is expected to be located in the same directory as this script.
- The file contains:
  - **Page ordering rules:** Represented as `x|y`, where `x` and `y` are integers specifying a pair of pages with ordering constraints.
  - **Page number sets:** Represented as `a,b,c,...`, where `a`, `b`, `c`, etc., are integers representing pages in a set.

## Workflow

### 1. Read and Parse Input
The script reads the contents of `test.txt` and splits it into individual items. Each item is classified as:
- **Page ordering rules:** Identified by the pattern `[0-9]+\|[0-9]+` and converted into tuples of integers.
- **Page number sets:** Identified as comma-separated integers and converted into lists of integers.

### 2. General Utility Function

#### Function: `find_instructions`
**Purpose**: Validates page number sets against the ordering rules and calculates the sum of middle values of valid page sets.

**Parameters**:
- `page_ordering_rules` (list of tuples): A list of tuples representing ordering constraints between pages.
- `page_numbers` (list of lists): A list of page number sets, each represented as a list of integers.
- `correct` (bool): A flag indicating the validation mode:
  - `True` for validating rules as correct orderings.
  - `False` for validating rules as incorrect orderings.

**Process**:
1. Initializes a list of dictionaries (`number_combinations`) for each page number set, containing:
   - `"page_numbers"`: The original page number set.
   - `"combinations"`: All possible pairs of pages from the set.
   - `"append"`: A boolean indicating whether the set is valid.
   - `"failed"`: A list to track failed rules.
2. Iterates through the page combinations and compares them with the ordering rules:
   - If a reversed rule (`rule[::-1]`) is found in the combinations, marks the set as invalid.
   - Otherwise, checks for valid rules and updates the status accordingly.
3. Collects all valid sets and calculates the sum of the middle values of their page numbers.
   - The middle value is determined as the element at `len(pages) // 2`.
4. Returns:
   - `correct_instructions`: A list of valid page number sets with their metadata.
   - `total_middle`: The sum of the middle values of valid sets.

**Returns**:
- A tuple containing:
  - A list of valid page sets with their metadata.
  - The sum of the middle values of valid sets.

---

### 3. Part 1: Validate with Correct Order
#### Function: `part1`
**Purpose**: Calculates the sum of middle values of page sets that satisfy the ordering rules in the correct direction.

**Process**:
1. Calls `find_instructions` with `correct=True` to validate the rules.
2. Extracts and prints the sum of the middle values of valid page sets.

**Output**:
- Prints the total sum of middle values for valid sets in Part 1.

---

### 4. Part 2: Validate with Incorrect Order
#### Function: `part2`
**Purpose**: Identifies page sets that fail the ordering rules and outputs their metadata.

**Process**:
1. Calls `find_instructions` with `correct=False` to validate the rules as incorrect.
2. Extracts and prints the metadata for the page sets that fail the ordering rules.

**Output**:
- Prints a list of metadata for invalid page sets in Part 2.

**Note**: Part 2 of the challenge is not fully solved.

---

### Dependencies
- `pathlib.Path`: For handling file paths in an OS-independent manner.
- `itertools.combinations`: For generating all pairs of pages from a set.
- `re`: For regular expression operations to identify patterns in the input.

---

### Key Patterns
- **Page ordering rule (`x|y`)**: Specifies an ordering constraint between two pages.
- **Page number set (`a,b,c,...`)**: A set of pages to validate against the rules.

---

## Notes
- The script assumes the input file is formatted correctly with no invalid entries.
- Part 2 functionality is partially implemented but not fully solved or tested.
- The design emphasizes flexibility and extensibility, allowing for additional validation modes or operations in the future.
"""
