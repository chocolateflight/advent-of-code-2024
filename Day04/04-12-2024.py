from pathlib import Path
import re

file_path = Path(__file__).with_name("input.txt")
with file_path.open("r") as f:
    file_content = [line.strip() for line in f.readlines()]

# -----General-----

def string_reverse(string):
    reversed_string = string[::-1]
    return reversed_string


def word_finder(string, pattern):
    word_matches = [
        [m.group(), m.start(), m.end()] for m in re.finditer(pattern, string)
    ]
    return word_matches


def horizontalize(array, reverse=True):
    horizontalized_strings = []

    for j in range(len(array)):
        temp_string = array[j]
        temp_dict = {
            "string": temp_string,
            "direction": "horizontal",
            "reversed": False,
            "row": j,
        }
        horizontalized_strings.append(temp_dict)

        if reverse:
            temp_reversed = string_reverse(temp_string)
            temp_dict_rev = {
                "string": temp_reversed,
                "direction": "horizontal",
                "reversed": True,
                "row": j,
            }
            horizontalized_strings.append(temp_dict_rev)

    return horizontalized_strings


def verticalize(array, reverse=True):
    number_row = len(array)
    number_col = len(array[0])

    verticalized_strings = []

    for i in range(number_col):
        current_row = 0
        temp_string = ""

        while current_row < number_row:
            temp_string += array[current_row][i]
            current_row += 1

        temp_dict = {
            "string": temp_string,
            "direction": "vertical",
            "reversed": False,
            "column": i,
        }
        verticalized_strings.append(temp_dict)

        if reverse:
            temp_reversed = string_reverse(temp_string)
            temp_dict_rev = {
                "string": temp_reversed,
                "direction": "vertical",
                "reversed": True,
                "column": i,
            }
            verticalized_strings.append(temp_dict_rev)

    return verticalized_strings


def diagonalize(array, reverse=True):
    number_row = len(array)
    number_col = len(array[0])
    diagonalized_strings = []

    for d in range(-(number_row - 1), number_col):
        temp_string = ""

        for i in range(number_row):
            j = i + d

            if 0 <= j < number_col:
                temp_string += array[i][j]

        if temp_string:
            temp_dict = {
                "string": temp_string,
                "direction": "diagonal",
                "reversed": False,
                "diagonal": d,
            }
            diagonalized_strings.append(temp_dict)

            if reverse:
                temp_reversed = temp_string[::-1]
                temp_dict_rev = {
                    "string": temp_reversed,
                    "direction": "diagonal",
                    "reversed": True,
                    "diagonal": d,
                }
                diagonalized_strings.append(temp_dict_rev)

    for d in range(number_row + number_col - 1):
        temp_string = ""

        for i in range(number_row):
            j = d - i

            if 0 <= j < number_col:
                temp_string += array[i][j]

        if temp_string:
            temp_dict = {
                "string": temp_string,
                "direction": "antidiagonal",
                "reversed": False,
                "antidiagonal": d,
            }
            diagonalized_strings.append(temp_dict)

            if reverse:
                temp_reversed = temp_string[::-1]
                temp_dict_rev = {
                    "string": temp_reversed,
                    "direction": "antidiagonal",
                    "reversed": True,
                    "antidiagonal": d,
                }
                diagonalized_strings.append(temp_dict_rev)

    return diagonalized_strings


def main(array, pattern=None, reverse=True):
    horizontal_strings = horizontalize(array)
    vertical_strings = verticalize(array)
    diagonal_strings = diagonalize(array)

    all_strings = [
        item
        for list in [horizontal_strings, vertical_strings, diagonal_strings]
        for item in list
    ]

    total_list = []

    for item in all_strings:
        found_words = word_finder(item["string"], pattern)

        if found_words:
            item["found_words"] = found_words
            item["total_matches"] = len(found_words)
            total_list.append(item)

    return total_list


# -----Code Part 1-----


def part1():
    pattern1 = r"XMAS"
    part1_matches = main(file_content, pattern1, True)

    total_number = 0
    
    for item in part1_matches:
      total_number += item["total_matches"]
      
    print(total_number)

part1()

# -----Code Part 2-----

def part2():
    pass


# -----Documentation-----
# This code for this challenge was written without the help of AI. The documentation was generated by ChatGPT.

"""
# Documentation for the Code

This script processes a word search puzzle to find all occurrences of a specific word ("XMAS") in a grid of letters. The script is intentionally designed to be more comprehensive than necessary for the current challenge, as it collects extensive information about each potential match and the directions in which words are searched. This was done to practice potential scalability with further features in mind.

**Note:** Part 2 of the challenge is not implemented in this script due to time constraints.

## Input File Format
- The input file is named `input.txt` and should be located in the same directory as this script.
- It contains a grid of letters, with each line representing a row in the grid.

## Workflow

### 1. Read and Parse Input
- The script reads the contents of `input.txt` into the `file_content` variable as a list of strings, stripping any leading and trailing whitespace from each line.

### 2. General Utility Functions
The script defines several utility functions to process the grid and search for the pattern.

#### Function: `string_reverse`
**Purpose**: Reverses a given string.

**Parameters**:
- `string` (str): The string to be reversed.

**Returns**:
- The reversed string.

#### Function: `word_finder`
**Purpose**: Finds all occurrences of a pattern in a given string using regular expressions.

**Parameters**:
- `string` (str): The string to search within.
- `pattern` (str): The regular expression pattern to search for.

**Returns**:
- A list of matches, where each match is a list containing the matched string, start index, and end index.

### 3. Directional String Generation Functions
These functions generate strings from the grid in different directions (horizontal, vertical, diagonal), including their reversed versions. They also collect detailed metadata about each string, such as its direction and position in the grid.

#### Function: `horizontalize`
**Purpose**: Generates all horizontal strings from the grid, including their reversed versions if specified.

**Parameters**:
- `array` (list of str): The grid of letters.
- `reverse` (bool): Whether to include reversed versions of the strings.

**Returns**:
- A list of dictionaries, each containing:
  - `"string"`: The horizontal string.
  - `"direction"`: `"horizontal"`.
  - `"reversed"`: `True` or `False`, indicating if the string is reversed.
  - `"row"`: The index of the row in the grid.

#### Function: `verticalize`
**Purpose**: Generates all vertical strings from the grid, including their reversed versions if specified.

**Parameters**:
- `array` (list of str): The grid of letters.
- `reverse` (bool): Whether to include reversed versions of the strings.

**Returns**:
- A list of dictionaries, each containing:
  - `"string"`: The vertical string.
  - `"direction"`: `"vertical"`.
  - `"reversed"`: `True` or `False`.
  - `"column"`: The index of the column in the grid.

#### Function: `diagonalize`
**Purpose**: Generates all diagonal and anti-diagonal strings from the grid, including their reversed versions if specified.

**Parameters**:
- `array` (list of str): The grid of letters.
- `reverse` (bool): Whether to include reversed versions of the strings.

**Returns**:
- A list of dictionaries, each containing:
  - `"string"`: The diagonal or anti-diagonal string.
  - `"direction"`: `"diagonal"` or `"antidiagonal"`.
  - `"reversed"`: `True` or `False`.
  - `"diagonal"` or `"antidiagonal"`: The identifier for the diagonal.

### 4. Main Function
#### Function: `main`
**Purpose**: Searches for a given pattern in all strings generated from the grid in different directions, and collects detailed information about each match.

**Parameters**:
- `array` (list of str): The grid of letters.
- `pattern` (str): The regular expression pattern to search for.
- `reverse` (bool): Whether to include reversed versions of the strings.

**Process**:
1. Generates strings in horizontal, vertical, and diagonal directions using the respective functions.
2. Combines all generated strings into a single list.
3. Iterates over each string and uses `word_finder` to search for the pattern.
4. If matches are found, adds the match information and total number of matches to the string's dictionary.
5. Collects all such dictionaries into `total_list`.

**Returns**:
- `total_list` (list of dict): A list of dictionaries containing information about each string where matches were found.

### 5. Part 1 Solution
#### Function: `part1`
**Purpose**: Solves Part 1 of the challenge by finding all occurrences of "XMAS" in the grid.

**Process**:
1. Defines the pattern to search for: `"XMAS"`.
2. Calls the `main` function to search for the pattern in all directions.
3. Iterates over the results and sums up the total number of matches found in all strings.
4. Prints the total number of matches.

**Output**:
- Prints the total number of times "XMAS" appears in the grid.

### 6. Part 2 Placeholder
#### Function: `part2`
**Purpose**: Placeholder function for Part 2 of the challenge.

**Note**: Part 2 is not implemented in this script due to time constraints.

### 7. Execution
- The script calls `part1()` to execute the Part 1 solution.

## Dependencies
- `pathlib.Path` for file handling.
- `re` for regular expression operations.

## Notes
- The code collects more information than necessary for the current challenge. This includes detailed metadata about each string and match, such as direction, position, and whether the string is reversed.
- This additional information is intended for practice in potential scalability and to facilitate future feature additions.
- The script assumes that the input file `input.txt` is correctly formatted and located in the same directory as the script.
- Part 2 of the challenge is acknowledged but not solved in this script due to time constraints.
"""
