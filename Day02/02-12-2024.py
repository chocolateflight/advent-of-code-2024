from pathlib import Path 
import itertools 

file_path = Path(__file__).with_name("input.txt")


with file_path.open("r") as f:
    file_content = f.readlines()
    
content = [list(map(int, line.strip().split())) for line in file_content]

# -----Code Part 1-----


def is_safe_report(report):
    differences = []
    for a, b in itertools.pairwise(report):
        differences.append(b - a)    
    same_direction = all(x > 0 for x in differences) or all(x < 0 for x in differences)
    differences_in_range = all(1 <= abs(x) <= 3 for x in differences)
    return same_direction and differences_in_range
    
safe_reports_part1 = []
for report in content:
    if is_safe_report(report):
        safe_reports_part1.append(report)

print(len(safe_reports_part1))

# -----Code Part 2-----

safe_reports_part2 = []
for report in content:
    if is_safe_report(report):
        safe_reports_part2.append(report)
    else:
        for i in range(len(report)):
            updated_report = report[:i] + report[i+1:]
            if is_safe_report(updated_report):
                safe_reports_part2.append(report)
                break

print(len(safe_reports_part2))


# -----Documentation-----
# This code for this challenge was written without the help of AI. The documentation was generated by ChatGPT.

"""
# Documentation for the Code

This script processes a file containing numerical reports and identifies "safe" reports based on specific conditions. It is divided into two main parts, each performing a distinct analysis of the reports. 

## Input File Format
The input file, named `input.txt`, is expected to be in the same directory as this script. It should contain:
- Each line representing a single report.
- Each report containing space-separated integers.

## Workflow

### 1. Read and Parse Input
- The script reads the `input.txt` file line by line.
- Each line is stripped of whitespace, split into integers, and stored as a list of integers.
- All the parsed reports are stored in the `content` variable, which is a list of lists.

### 2. Safe Report Definition
The script uses the `is_safe_report` function to determine if a report is "safe." A report is considered safe if:
1. **Consistent Direction**: All consecutive differences between numbers are either strictly positive or strictly negative.
2. **Difference Range**: The absolute value of all differences between consecutive numbers is between 1 and 3 (inclusive).

#### Function: `is_safe_report`
**Parameters**:
- `report` (list of integers): A single report to evaluate.

**Returns**:
- `True` if the report meets both conditions, otherwise `False`.

**Logic**:
- Computes differences between consecutive elements using `itertools.pairwise`.
- Checks for consistent direction using `all(x > 0)` or `all(x < 0)`.
- Checks if all differences fall within the range 1 to 3 using `all(1 <= abs(x) <= 3)`.

### 3. Part 1: Identifying Completely Safe Reports
- Iterates through all reports in `content`.
- Adds reports satisfying the `is_safe_report` condition to `safe_reports_part1`.
- Outputs the number of such safe reports.

### 4. Part 2: Identifying Potentially Safe Reports
- Iterates through all reports in `content`.
- For each report:
  - If it is safe, adds it to `safe_reports_part2`.
  - If not, removes one number at a time and checks if the modified report becomes safe:
    - Adds the original report to `safe_reports_part2` if at least one modified version is safe.
- Outputs the number of such reports.

### Output
- The script prints two integers:
  1. The number of completely safe reports (Part 1).
  2. The number of potentially safe reports, accounting for single-item removals (Part 2).

## Dependencies
- `pathlib.Path` for file handling.
- `itertools.pairwise` for calculating consecutive differences.

## Notes
- The script assumes that the input file exists and is formatted correctly.
- The script modifies reports temporarily in Part 2 but always evaluates and stores the original report.
"""